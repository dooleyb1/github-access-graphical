{"ast":null,"code":"'use strict';\n\nmodule.exports = validate;\n\nvar set = require('lodash/set');\n\nvar get = require('lodash/get');\n\nvar HttpError = require('../../request/http-error');\n\nvar deprecate = require('../../deprecate');\n\nfunction validate(endpointParams, options) {\n  // Alias are handled before validation, as validation rules\n  // ar set the aliased parameter. The `mapTo` property is the other way\n  // around, the final parameter name is the mapTo value, but validation\n  // rules are on parameter with the mapTo property\n  Object.keys(options).forEach(function (optionName) {\n    if (!endpointParams[optionName] || !endpointParams[optionName].alias) {\n      return;\n    }\n\n    set(options, endpointParams[optionName].alias, options[optionName]);\n    delete options[optionName]; // right now all parameters with an alias property also have a deprecated\n    // property, but that might change in future, so we wrap it in the if block,\n    // but ignore if for coverage\n\n    /* istanbul ignore else */\n\n    if (endpointParams[optionName].deprecated) {\n      deprecate(\"\\\"\".concat(optionName, \"\\\" parameter has been renamed to \\\"\").concat(endpointParams[optionName].alias, \"\\\"\"));\n    }\n  });\n  Object.keys(endpointParams).forEach(function (parameterName) {\n    var parameter = get(endpointParams, parameterName);\n    var expectedType = parameter.type;\n    var parentParameterName;\n    var parentValue;\n    var parentParamIsPresent = true;\n    var parentParameterIsArray = false;\n\n    if (/\\./.test(parameterName)) {\n      parentParameterName = parameterName.replace(/\\.[^.]+$/, '');\n      parentParameterIsArray = parentParameterName.slice(-2) === '[]';\n\n      if (parentParameterIsArray) {\n        parentParameterName = parentParameterName.slice(0, -2);\n      }\n\n      parentValue = get(options, parentParameterName);\n      parentParamIsPresent = parentParameterName === 'headers' || typeof parentValue === 'object' && parentValue !== null;\n    }\n\n    var values = parentParameterIsArray ? (get(options, parentParameterName) || []).map(function (value) {\n      return value[parameterName.split(/\\./).pop()];\n    }) : [get(options, parameterName)];\n    values.forEach(function (value, i) {\n      var valueIsPresent = typeof value !== 'undefined';\n      var valueIsNull = value === null;\n      var currentParameterName = parentParameterIsArray ? parameterName.replace(/\\[\\]/, \"[\".concat(i, \"]\")) : parameterName;\n\n      if (!parameter.required && !valueIsPresent) {\n        return;\n      } // if the parent parameter is of type object but allows null\n      // then the child parameters can be ignored\n\n\n      if (!parentParamIsPresent) {\n        return;\n      }\n\n      if (parameter.allowNull && valueIsNull) {\n        return;\n      }\n\n      if (!parameter.allowNull && valueIsNull) {\n        throw new HttpError(\"'\".concat(currentParameterName, \"' cannot be null\"), 400);\n      }\n\n      if (parameter.required && !valueIsPresent) {\n        throw new HttpError(\"Empty value for parameter '\".concat(currentParameterName, \"': \").concat(JSON.stringify(value)), 400);\n      } // parse to integer before checking for enum\n      // so that string \"1\" will match enum with number 1\n\n\n      if (expectedType === 'integer') {\n        var unparsedValue = value;\n        value = parseInt(value, 10);\n\n        if (isNaN(value)) {\n          throw new HttpError(\"Invalid value for parameter '\".concat(currentParameterName, \"': \").concat(JSON.stringify(unparsedValue), \" is NaN\"), 400);\n        }\n      }\n\n      if (parameter.enum && parameter.enum.indexOf(value) === -1) {\n        throw new HttpError(\"Invalid value for parameter '\".concat(currentParameterName, \"': \").concat(JSON.stringify(value)), 400);\n      }\n\n      if (parameter.validation) {\n        var regex = new RegExp(parameter.validation);\n\n        if (!regex.test(value)) {\n          throw new HttpError(\"Invalid value for parameter '\".concat(currentParameterName, \"': \").concat(JSON.stringify(value)), 400);\n        }\n      }\n\n      if (expectedType === 'object' && typeof value === 'string') {\n        try {\n          value = JSON.parse(value);\n        } catch (exception) {\n          throw new HttpError(\"JSON parse error of value for parameter '\".concat(currentParameterName, \"': \").concat(JSON.stringify(value)), 400);\n        }\n      }\n\n      set(options, parameter.mapTo || currentParameterName, value);\n    });\n  });\n  return options;\n}","map":null,"metadata":{},"sourceType":"script"}